import { promises as fs } from 'fs';
import path from 'path';
import crypto from 'crypto';

// ----------------------
// CONFIG (edit as needed)
// ----------------------
const ROOT_DIR = path.resolve('dist-types/exports'); // folder with your .d.ts files
const OUTPUT_FILE = path.resolve('index.d.ts'); // generated index
const SKIP_DIRS = /^(node_modules|dist|build|out|coverage|\.git)$/i;
// ----------------------

async function pathExists(p) {
  try {
    await fs.access(p);
    return true;
  } catch {
    return false;
  }
}

async function walkAllDtsFiles(rootDir) {
  const results = [];
  const pending = [rootDir];

  while (pending.length) {
    const current = pending.pop();
    let entries;
    try {
      entries = await fs.readdir(current, { withFileTypes: true });
    } catch {
      continue; // ignore unreadable dirs
    }

    for (const e of entries) {
      const full = path.join(current, e.name);
      if (e.isDirectory()) {
        if (!SKIP_DIRS.test(e.name)) pending.push(full);
      } else if (e.isFile() && e.name.endsWith('.d.ts')) {
        results.push(full);
      }
    }
  }
  return results;
}

function toPosixRelative(fromDir, targetFile) {
  let rel = path.relative(fromDir, targetFile);
  if (!rel.startsWith('.')) rel = './' + rel;
  return rel.split(path.sep).join('/');
}

function looksLikeModule(contents) {
  // Heuristic: treat as module if it visibly contains import/export or declare module "..."
  return /(^|\s)(export\s+|import\s+|declare\s+module\s+['"])/m.test(contents);
}

async function validateExactDtsSpecifier(outDir, absFilePath) {
  // We now include the .d.ts extension in exports, so ensure that *exact* file exists from the perspective of outDir.
  const relWithExt = toPosixRelative(outDir, absFilePath); // includes .d.ts
  const absFromOutDir = path.resolve(outDir, relWithExt);
  if (await pathExists(absFromOutDir)) {
    return relWithExt; // use exact path with extension
  }
  return null; // fallback to triple-slash by caller
}

function hash(buf) {
  return crypto.createHash('sha256').update(buf).digest('hex');
}

async function main() {
  if (!(await pathExists(ROOT_DIR))) {
    console.error(`Root directory does not exist: ${ROOT_DIR}`);
    process.exit(1);
  }

  const outDir = path.dirname(OUTPUT_FILE);

  let files = await walkAllDtsFiles(ROOT_DIR);
  // Exclude the output file itself
  files = files.filter(f => path.resolve(f) !== path.resolve(OUTPUT_FILE));
  files.sort();

  const moduleExports = [];
  const tripleRefs = [];
  const unresolved = [];

  for (const abs of files) {
    let content = '';
    try {
      content = await fs.readFile(abs, 'utf8');
    } catch {
      continue;
    }

    const relWithExt = toPosixRelative(outDir, abs);
    const isModule = looksLikeModule(content);

    if (isModule) {
      const spec = await validateExactDtsSpecifier(outDir, abs);
      if (spec) {
        // âœ… include .d.ts extension in export specifier
        moduleExports.push(`export * from '${spec}';`);
      } else {
        // Fallback: triple-slash reference to avoid unresolved module error
        tripleRefs.push(`/// <reference path="${relWithExt}" />`);
        unresolved.push(relWithExt);
      }
    } else {
      // Global declarations: triple-slash reference
      tripleRefs.push(`/// <reference path="${relWithExt}" />`);
    }
  }

  const banner = '// Generated by generate-index-dts.mjs \n';

  const lines = [];
  if (tripleRefs.length) {
    lines.push('// Global declaration references (and unresolved modules fallback)');
    lines.push(...tripleRefs, '');
  }
  if (moduleExports.length) {
    lines.push(...moduleExports, '');
  }

  if (unresolved.length) {
    lines.push(
      '// NOTE: The following module files could not be validated as resolvable and were referenced via triple-slash:',
    );
    for (const u of unresolved) lines.push(`//   - ${u}`);
    lines.push('');
  }

  const content = banner + lines.join('\n');

  // Only write if changed
  let shouldWrite = true;
  if (await pathExists(OUTPUT_FILE)) {
    const old = await fs.readFile(OUTPUT_FILE);
    const oldHash = hash(old);
    const newHash = hash(Buffer.from(content, 'utf8'));
    shouldWrite = oldHash !== newHash;
  } else {
    await fs.mkdir(outDir, { recursive: true });
  }

  if (shouldWrite) {
    await fs.writeFile(OUTPUT_FILE, content, 'utf8');
    console.log(`index.d.ts updated (${files.length} files scanned)`);
  } else {
    console.log('index.d.ts unchanged');
  }
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});
